# Subclassing with class, extends & super

Final standard approach to achieve **OOP**, which as we see earlier its just **Prototyple Sturucture** behind the scenes. but even though
we will simulate **OOP** within a **Prototyple** envirenment.

## Create normal user using Class

```
class userCreator {
  constructor(name, score) {
    this.name = name;
    this.score = score;
  }

  incrementScore() {
    this.score++;
  }

  sayName() {
    console.log("hello", this.name);
  }
}

const user1 = new userCreator("azedine", 10);
user1.sayName();
user1.incrementScore();
console.log(user1.name);
```

`class userCreator`: its just a function object combo, and its function bit has now subtitle `constructor`, that doesn't mean too much its just the function and function object combo => when we run `userCreator` we run `constructor` bit of it => tha is we run function in the function object combo as earlier => **Prototype** => at the end its just a prototype.

memory flow:

![](images/img11.png?raw=true)

As we see in **global excution context** (right side), javascript engine create a function + object bit, and javascript engine grap immmediatly the constructor bit and stick it on the function bi on the function object combo, also js engine grap `sayName` and `incrmentScore` and put them on `Prototype` of the object in the function object combo.

### User1 lookup journey

When we try to create `user1` we call constructor of the class but as we said its just a function in function object combo => js engine create a new excution context => `new` keyword automate some work for us, an empty object gets created weith `__Proto__` set to **Prototype** object of `userCreator` => finally in `this` object the property of `name` and `score` got setted => `this` object got returned to `user1` object.

=> `class` make our life more easier than dealing with prototype inheritance.

## Create Paid User

```
class userCreator {
  constructor(name, score) {
    this.name = name;
    this.score = score;
  }

  incrementScore() {
    this.score++;
  }

  sayName() {
    console.log("hello", this.name);
  }
}

// paidUser

class paidUserCreator extends userCreator {
  constructor(paidName, score, accountBalance) {
    super(paidName, score);
    this.accountBalance = accountBalance;
  }

  incrementBalance() {
    this.accountBalance++;
  }
}

const paidUser1 = new paidUserCreator("xperaz", 100, 250);
paidUser1.sayName();
paidUser1.incrementScore();
paidUser1.incrementBalance();

console.log(paidUser1);

```

We start by defining new `paidUserCreator` Subclass, and adding `accountBalance` property and `incrementBalance` method, but there is something new here!!:

**extends**: going to do two major things for us:
1- first thing extend set that `__Proto__` as refrence up to `userCreator` prototype before we did it manually but now extend do it for us.
2- second thing sets `paidUserCreator` the function it's `__Proto__` to the `userCreator` function object combo.

### Creating object with a Subclass

**memory flow**:

![](images/img12.png?raw=true)

=> After invoking `new paidUserCreator`, a new execution context got created, js will create also an uninitialized `this` object, actually this object gonna burn in `userCreator` and that is a design decision of javascript team.=> and then its automatically returned it out and assigned it to `this` in `paidUserCreator`.

=> We call `userCreator` constructor with the help of `super`.

## Super in Subclass constructor.

- `super` call `userCreator` same as we call it early with `new userCreator`, js engine will create a new execution context, and create an empty object `this`automatically, but this time the `this` keyword wil not have `__Proto__` to `userCreator.prototype` as before, instead will override it to have reference to `paidUserCreator.prototype`.

- Behind the scenes **super** uses `Reflect.construct()`,=> After filling user information in `userCreator` the `this` object got returned to our `this` in `paidUserCreator` => after that we add balance property to that user and return `this` object to `paidUser1`.

> [MDN]  
> The `Reflect.construct()` static method is like the `new` operator, but as a function. It is equivalent to calling `new target(...args)`.It additionally allows to specify a different `new.target` value.

## Conclusion

Now we achieve the `Subclassing` solution which more cleaner than our previous solutions with `prototypes`, and we know how (`OOP`) exactly works under the hood when it comes to javascript.

## Resources

[Reflect.construct()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/construct)
[OOP Hard Parts](https://frontendmasters.com/courses/object-oriented-js/)
